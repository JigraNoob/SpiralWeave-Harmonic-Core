#!/usr/bin/env node

// node_modules/.pnpm/tsup@6.2.3_typescript@4.8.2/node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// src/index.ts
import fs5 from "node:fs";
import path6 from "node:path";
import { program } from "commander";
import chalk from "chalk";
import ora2 from "ora";

// src/constants.ts
import os from "node:os";
import fs from "node:fs";
import path2 from "node:path";
var PACKAGE_JSON = JSON.parse(
  fs.readFileSync(path2.join(__dirname, "..", "package.json"), "utf8")
);
var MODEL_DIR = process.env.MODEL_DIR || path2.join(os.homedir(), "vosk-models");
if (!fs.existsSync(MODEL_DIR)) {
  fs.mkdirSync(MODEL_DIR, { recursive: true });
}
var MODELS = {
  english: [
    {
      name: "vosk-model-small-en-us-0.15",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-en-us-0.15.zip",
      size: 41943040,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-en-us-0.22-lgraph",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-0.22-lgraph.zip",
      size: 134217728,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-en-us-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-0.22.zip",
      size: 1932735283,
      license: "Apache 2.0"
    }
  ],
  "english-other": [
    {
      name: "vosk-model-small-en-us-zamia-0.5",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-en-us-zamia-0.5.zip",
      size: 51380224,
      license: "LGPL-3.0"
    },
    {
      name: "vosk-model-en-us-daanzu-20200905-lgraph",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-daanzu-20200905-lgraph.zip",
      size: 135266304,
      license: "AGPL"
    },
    {
      name: "vosk-model-en-us-librispeech-0.2",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-librispeech-0.2.zip",
      size: 886046720,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-en-us-daanzu-20200905",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-daanzu-20200905.zip",
      size: 1073741824,
      license: "AGPL"
    },
    {
      name: "vosk-model-en-us-aspire-0.2",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-aspire-0.2.zip",
      size: 1503238553,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-en-us-0.21",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-us-0.21.zip",
      size: 1717986918,
      license: "Apache 2.0"
    }
  ],
  "indian-english": [
    {
      name: "vosk-model-small-en-in-0.4",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-en-in-0.4.zip",
      size: 37748736,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-en-in-0.5",
      url: "https://alphacephei.com/vosk/models/vosk-model-en-in-0.5.zip",
      size: 1073741824,
      license: "Apache 2.0"
    }
  ],
  chinese: [
    {
      name: "vosk-model-small-cn-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip",
      size: 44040192,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-cn-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-cn-0.22.zip",
      size: 1395864371,
      license: "Apache 2.0"
    }
  ],
  "chinese-other": [
    {
      name: "vosk-model-cn-kaldi-multicn-0.15",
      url: "https://alphacephei.com/vosk/models/vosk-model-cn-kaldi-multicn-0.15.zip",
      size: 1610612736,
      license: "Apache 2.0"
    }
  ],
  russian: [
    {
      name: "vosk-model-small-ru-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-ru-0.22.zip",
      size: 47185920,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-ru-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-ru-0.22.zip",
      size: 1610612736,
      license: "Apache 2.0"
    }
  ],
  "russian-other": [
    {
      name: "vosk-model-ru-0.10",
      url: "https://alphacephei.com/vosk/models/vosk-model-ru-0.10.zip",
      size: 2684354560,
      license: "Apache 2.0"
    }
  ],
  french: [
    {
      name: "vosk-model-small-fr-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-fr-0.22.zip",
      size: 42991616,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-fr-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-fr-0.22.zip",
      size: 1503238553,
      license: "Apache 2.0"
    }
  ],
  "french-other": [
    {
      name: "vosk-model-small-fr-pguyot-0.3",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-fr-pguyot-0.3.zip",
      size: 40894464,
      license: "CC-BY-NC-SA 4.0"
    },
    {
      name: "vosk-model-fr-0.6-linto-2.2.0",
      url: "https://alphacephei.com/vosk/models/vosk-model-fr-0.6-linto-2.2.0.zip",
      size: 1610612736,
      license: "AGPL"
    }
  ],
  german: [
    {
      name: "vosk-model-small-de-0.15",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-de-0.15.zip",
      size: 47185920,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-small-de-zamia-0.3",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-de-zamia-0.3.zip",
      size: 51380224,
      license: "LGPL-3.0"
    },
    {
      name: "vosk-model-de-0.21",
      url: "https://alphacephei.com/vosk/models/vosk-model-de-0.21.zip",
      size: 2040109465,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-de-tuda-0.6-900k",
      url: "https://alphacephei.com/vosk/models/vosk-model-de-tuda-0.6-900k.zip",
      size: 4724464025,
      license: "Apache 2.0"
    }
  ],
  spanish: [
    {
      name: "vosk-model-small-es-0.42",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-es-0.42.zip",
      size: 40894464,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-es-0.42",
      url: "https://alphacephei.com/vosk/models/vosk-model-es-0.42.zip",
      size: 1503238553,
      license: "Apache 2.0"
    }
  ],
  portuguese: [
    {
      name: "vosk-model-small-pt-0.3",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-pt-0.3.zip",
      size: 32505856,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-pt-fb-v0.1.1-20220516_2113",
      url: "https://alphacephei.com/vosk/models/vosk-model-pt-fb-v0.1.1-20220516_2113.zip",
      size: 1717986918,
      license: "GPLv3.0"
    }
  ],
  greek: [
    {
      name: "vosk-model-el-gr-0.7",
      url: "https://alphacephei.com/vosk/models/vosk-model-el-gr-0.7.zip",
      size: 1181116006,
      license: "Apache 2.0"
    }
  ],
  turkish: [
    {
      name: "vosk-model-small-tr-0.3",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-tr-0.3.zip",
      size: 36700160,
      license: "Apache 2.0"
    }
  ],
  vietnamese: [
    {
      name: "vosk-model-small-vn-0.3",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-vn-0.3.zip",
      size: 33554432,
      license: "Apache 2.0"
    }
  ],
  italian: [
    {
      name: "vosk-model-small-it-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-it-0.22.zip",
      size: 50331648,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-it-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-it-0.22.zip",
      size: 1288490188,
      license: "Apache 2.0"
    }
  ],
  dutch: [
    {
      name: "vosk-model-small-nl-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-nl-0.22.zip",
      size: 40894464,
      license: "Apache 2.0"
    }
  ],
  "dutch-other": [
    {
      name: "vosk-model-nl-spraakherkenning-0.6-lgraph",
      url: "https://alphacephei.com/vosk/models/vosk-model-nl-spraakherkenning-0.6-lgraph.zip",
      size: 104857600,
      license: "CC-BY-NC-SA"
    },
    {
      name: "vosk-model-nl-spraakherkenning-0.6",
      url: "https://alphacephei.com/vosk/models/vosk-model-nl-spraakherkenning-0.6.zip",
      size: 901775360,
      license: "CC-BY-NC-SA"
    }
  ],
  catalan: [
    {
      name: "vosk-model-small-ca-0.4",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-ca-0.4.zip",
      size: 44040192,
      license: "Apache 2.0"
    }
  ],
  arabic: [
    {
      name: "vosk-model-ar-mgb2-0.4",
      url: "https://alphacephei.com/vosk/models/vosk-model-ar-mgb2-0.4.zip",
      size: 333447168,
      license: "Apache 2.0"
    }
  ],
  farsi: [
    {
      name: "vosk-model-small-fa-0.4",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-fa-0.4.zip",
      size: 49283072,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-small-fa-0.5",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-fa-0.5.zip",
      size: 62914560,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-fa-0.5",
      url: "https://alphacephei.com/vosk/models/vosk-model-fa-0.5.zip",
      size: 1073741824,
      license: "Apache 2.0"
    }
  ],
  filipino: [
    {
      name: "vosk-model-tl-ph-generic-0.6",
      url: "https://alphacephei.com/vosk/models/vosk-model-tl-ph-generic-0.6.zip",
      size: 335544320,
      license: "CC-BY-NC-SA 4.0"
    }
  ],
  ukrainian: [
    {
      name: "vosk-model-small-uk-v3-nano",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-uk-v3-nano.zip",
      size: 76546048,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-small-uk-v3-small",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-uk-v3-small.zip",
      size: 139460608,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-uk-v3-lgraph",
      url: "https://alphacephei.com/vosk/models/vosk-model-uk-v3-lgraph.zip",
      size: 340787200,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-uk-v3",
      url: "https://alphacephei.com/vosk/models/vosk-model-uk-v3.zip",
      size: 359661568,
      license: "Apache 2.0"
    }
  ],
  kazakh: [
    {
      name: "vosk-model-small-kz-0.15",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-kz-0.15.zip",
      size: 44040192,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-kz-0.15",
      url: "https://alphacephei.com/vosk/models/vosk-model-kz-0.15.zip",
      size: 396361728,
      license: "Apache 2.0"
    }
  ],
  swedish: [
    {
      name: "vosk-model-small-sv-rhasspy-0.15",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-sv-rhasspy-0.15.zip",
      size: 303038464,
      license: "MIT"
    }
  ],
  japanese: [
    {
      name: "vosk-model-small-ja-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-ja-0.22.zip",
      size: 50331648,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-ja-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-ja-0.22.zip",
      size: 1073741824,
      license: "Apache 2.0"
    }
  ],
  esperanto: [
    {
      name: "vosk-model-small-eo-0.42",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-eo-0.42.zip",
      size: 44040192,
      license: "Apache 2.0"
    }
  ],
  hindi: [
    {
      name: "vosk-model-small-hi-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-hi-0.22.zip",
      size: 44040192,
      license: "Apache 2.0"
    },
    {
      name: "vosk-model-hi-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-hi-0.22.zip",
      size: 1610612736,
      license: "Apache 2.0"
    }
  ],
  czech: [
    {
      name: "vosk-model-small-cs-0.4-rhasspy",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-cs-0.4-rhasspy.zip",
      size: 46137344,
      license: "MIT"
    }
  ],
  polish: [
    {
      name: "vosk-model-small-pl-0.22",
      url: "https://alphacephei.com/vosk/models/vosk-model-small-pl-0.22.zip",
      size: 52953088,
      license: "Apache 2.0"
    }
  ],
  "speaker-identification-model": [
    {
      name: "vosk-model-spk-0.4",
      url: "https://alphacephei.com/vosk/models/vosk-model-spk-0.4.zip",
      size: 13631488,
      license: "Apache 2.0"
    }
  ]
};

// src/downloader.ts
import EventEmitter from "node:events";
import fs2 from "node:fs";
import path3 from "node:path";
import { get } from "node:https";
import yauzl from "yauzl";
var ModelDownloader = class extends EventEmitter {
  constructor(url, name) {
    super();
    this.url = url;
    this.name = name;
  }
  log(...args) {
    this.emit("log", ...args);
  }
  error(...args) {
    this.emit("error", ...args);
  }
  async download(to) {
    const file = fs2.createWriteStream(to);
    this.log(`Downloading ${this.name} ...`);
    return new Promise((resolve, reject) => {
      get(this.url, (res) => {
        const redirection = res.headers.location;
        if (res.statusCode && Math.floor(res.statusCode / 100) === 3 && redirection) {
          file.close(() => {
            this.url = redirection;
            this.download(to).then(resolve, reject);
          });
        } else {
          res.pipe(file);
          res.on("data", () => {
            this.log(
              `Downloading... ${(file.bytesWritten / 1024 / 1024).toFixed(1)} MB`
            );
          });
          file.on("finish", () => {
            file.close();
            resolve();
          });
        }
      }).on("error", (error) => {
        fs2.unlinkSync(to);
        reject(error);
      });
    });
  }
  unzip(zip, dest) {
    const dir = path3.basename(zip, ".zip");
    return new Promise((resolve, reject) => {
      yauzl.open(zip, { lazyEntries: true }, (err, zipfile) => {
        if (err) {
          reject(err);
        }
        zipfile.readEntry();
        zipfile.on("entry", (entry) => {
          if (/\/$/.test(entry.fileName)) {
            zipfile.readEntry();
          } else {
            zipfile.openReadStream(entry, (err2, stream) => {
              if (err2) {
                reject(err2);
              }
              const file = path3.resolve(
                dest,
                entry.fileName.replace(`${dir}/`, "")
              );
              if (!fs2.existsSync(path3.dirname(file))) {
                fs2.mkdirSync(path3.dirname(file), { recursive: true });
                this.log("Created", path3.dirname(file));
              }
              stream.pipe(fs2.createWriteStream(file));
              stream.on("end", () => {
                this.log("Extracted", file);
                zipfile.readEntry();
              }).on("error", (err3) => {
                reject(err3);
              });
            });
          }
        }).on("error", (err2) => {
          reject(err2);
        }).on("end", () => {
          this.log("Extracted all files");
          fs2.writeFileSync(path3.resolve(dest, "DONE"), new Date().toString());
        }).on("close", () => {
          resolve();
        });
      });
    });
  }
  async install(from) {
    const zip = from || path3.join(MODEL_DIR, this.name + ".zip");
    const dir = path3.join(MODEL_DIR, this.name);
    if (!from) {
      try {
        await this.download(zip);
        this.log(`Downloaded ${this.name}`);
      } catch (err) {
        this.error(`Failed to download ${this.name}`);
        this.error(err);
        return;
      }
    }
    try {
      await this.unzip(zip, dir);
      this.log(`Unzipped ${this.name}`);
      if (!from) {
        fs2.unlinkSync(zip);
      }
    } catch (err) {
      this.error(`Failed to unzip ${this.name}`);
      this.error(err);
      return;
    }
  }
};

// src/resolve.ts
import fs3 from "node:fs";
import path4 from "node:path";
function resolve_model(model_name) {
  if (fs3.existsSync(path4.join(MODEL_DIR, model_name, "DONE"))) {
    return model_name;
  }
  model_name = model_name.toLowerCase();
  if (Object.keys(MODELS).includes(model_name)) {
    return MODELS[model_name][0].name;
  }
  if (!model_name.startsWith("vosk-model-")) {
    model_name = "vosk-model-" + model_name;
  }
  const models = Object.values(MODELS).flat().filter((m) => m.name.startsWith(model_name));
  for (const model of models) {
    if (model.name === model_name) {
      return model_name;
    }
  }
  if (models.length === 0) {
    console.error(`Model ${model_name} not found`);
    process.exit(1);
  }
  if (models.length > 1) {
    console.error(`Multiple models found: ${models.map((m) => m.name).join(", ")}`);
    process.exit(1);
  }
  return models[0].name;
}

// src/recognize.ts
import fs4 from "node:fs";
import { Readable } from "node:stream";
import vosk from "vosk-lib";
import wav from "wav";
function recognize(model_root, audio_file, ora3) {
  vosk.setLogLevel(-1);
  const model = new vosk.Model(model_root);
  const stream = fs4.createReadStream(audio_file, { highWaterMark: 4096 });
  const reader = new wav.Reader();
  const readable = new Readable().wrap(reader);
  return new Promise((resolve) => {
    reader.on("format", ({ audioFormat, sampleRate, channels }) => {
      if (audioFormat != 1 || channels != 1) {
        throw new Error("Audio file must be mono PCM WAV.");
      }
      const rec = new vosk.Recognizer({ model, sampleRate });
      rec.setMaxAlternatives(1);
      rec.setWords(true);
      rec.setPartialWords(true);
      const results = [];
      readable.on("data", (data) => {
        var _a, _b, _c;
        const end_of_sentence = rec.acceptWaveform(data);
        if (end_of_sentence) {
          const { alternatives } = rec.result();
          if (alternatives[0].text) {
            const sentence = alternatives[0].text;
            const start = (_a = alternatives[0].result) == null ? void 0 : _a[0].start;
            const end = (_c = alternatives[0].result) == null ? void 0 : _c[((_b = alternatives[0].result) == null ? void 0 : _b.length) - 1].end;
            results.push({ sentence, start, end });
            if (ora3) {
              ora3.text = `Recognized ${end.toFixed(1)} seconds: ${sentence}`;
            }
          }
        }
      });
      readable.on("end", () => {
        var _a, _b, _c;
        const { alternatives } = rec.finalResult();
        if (alternatives[0].text) {
          results.push({
            sentence: alternatives[0].text,
            start: (_a = alternatives[0].result) == null ? void 0 : _a[0].start,
            end: (_c = alternatives[0].result) == null ? void 0 : _c[((_b = alternatives[0].result) == null ? void 0 : _b.length) - 1].end
          });
        }
        resolve(results);
        rec.free();
        model.free();
      });
    });
    stream.pipe(reader);
  });
}

// src/convert.ts
import os2 from "node:os";
import path5 from "node:path";
import { spawnSync } from "node:child_process";
function convert(source, ffmpeg = "ffmpeg") {
  const temp = path5.resolve(os2.tmpdir(), `converted_${path5.basename(source)}.wav`);
  const args = [
    "-loglevel",
    "error",
    "-i",
    path5.basename(source),
    "-acodec",
    "pcm_s16le",
    "-ac",
    "1",
    "-ar",
    "16000",
    temp
  ];
  spawnSync(ffmpeg, args, { cwd: path5.dirname(source), stdio: "ignore" });
  return temp;
}

// src/microphone.ts
import EventEmitter2 from "node:events";
import mic from "mic";
import vosk2 from "vosk-lib";
import ora from "ora";
var Microphone = class extends EventEmitter2 {
  model;
  mic;
  spinner;
  constructor(model_root) {
    super();
    vosk2.setLogLevel(-1);
    this.model = new vosk2.Model(model_root);
  }
  start() {
    this.spinner = ora("Initializing").start();
    const spinner = this.spinner || ora();
    this.mic = mic();
    const stream = this.mic.getAudioStream();
    const rec = new vosk2.Recognizer({ model: this.model, sampleRate: 16e3 });
    rec.setMaxAlternatives(1);
    rec.setWords(true);
    rec.setPartialWords(true);
    spinner.text = "Listening";
    stream.on("data", (data) => {
      if (rec.acceptWaveform(data)) {
        const result = rec.result();
        const sentence = result.alternatives[0].text;
        if (sentence) {
          spinner.info(sentence).start("Listening");
          this.emit("sentence", sentence);
        }
      } else {
        const result = rec.partialResult();
        const sentence = result.partial;
        if (sentence) {
          spinner.text = sentence;
        }
      }
    });
    stream.on("audioProcessExitComplete", () => {
      const result = rec.finalResult();
      const sentence = result.alternatives[0].text;
      if (sentence) {
        spinner.info(sentence).succeed("Done");
        this.emit("sentence", sentence);
      }
      rec.free();
    });
    this.mic.start();
  }
  stop() {
    var _a, _b;
    (_a = this.spinner) == null ? void 0 : _a.stop();
    (_b = this.mic) == null ? void 0 : _b.stop();
  }
};

// src/utils.ts
function semantic_size(size, fixed = 1) {
  const prefix = ["B", "K", "M", "G"];
  let idx = 0;
  while (size >= 1024 && idx < prefix.length) {
    idx++;
    size /= 1024;
  }
  return `${size.toFixed(fixed)}${prefix[idx]}`;
}

// src/index.ts
program.version(`${PACKAGE_JSON.name} ${PACKAGE_JSON.version}`).description(PACKAGE_JSON.description);
program.command("list").alias("ls").description("List all the models available").action(() => {
  Object.entries(MODELS).forEach(([key, models]) => {
    console.log(chalk.bold(key));
    for (const model of models) {
      console.group();
      const exists = fs5.existsSync(path6.join(MODEL_DIR, model.name, "DONE"));
      const size = chalk.yellow(`(${semantic_size(model.size)})`);
      const info = `${model.name} ${size} ${chalk.magenta(model.license)}`;
      if (exists) {
        console.log(chalk.green(info));
      } else {
        console.log(info);
      }
      console.groupEnd();
    }
  });
});
program.command("install <model>").alias("i").description("Install a model").option("-f, --from <archive>", "Install from archive (zip)").action(async (model, opts) => {
  const name = opts.from ? model : resolve_model(model);
  const target = Object.values(MODELS).flat().find((m) => m.name === name);
  if (!target) {
    console.error(chalk.red(`Model ${name} not found`));
    process.exit(1);
  }
  const installed = fs5.existsSync(path6.join(MODEL_DIR, name, "DONE"));
  if (installed) {
    console.log(chalk.green(`Model ${name} already installed`));
    process.exit(0);
  }
  const spinner = ora2(`Downloading ${name} ...`).start();
  const downloader = opts.from ? new ModelDownloader("", name) : new ModelDownloader(target.url, name);
  downloader.on("log", (...args) => {
    spinner.text = args.join(" ");
  });
  downloader.on("error", (...args) => {
    spinner.fail(args.join(" "));
  });
  await downloader.install(opts.from);
  spinner.succeed(`Successfully installed ${name}`);
});
program.command("remove <model>").alias("rm").description("Remove a model").action((model) => {
  const name = resolve_model(model);
  const zip = path6.join(MODEL_DIR, `${name}.zip`);
  const dir = path6.join(MODEL_DIR, name);
  if (fs5.existsSync(zip)) {
    fs5.rmSync(zip);
  }
  if (fs5.existsSync(dir)) {
    fs5.rmSync(dir, { recursive: true });
  }
  console.log(chalk.green(`Successfully removed ${name}`));
});
program.command("recognize <model> <audio>").alias("rec").description("Recognize text from an audio file").option("-c, --convert", "Convert source audio to 16000 Hz mono WAV file first").option("-s, --silent", "Print the result only").option("-t, --text", "Print the result as text only").action(async (model, audio, opts) => {
  const name = resolve_model(model);
  const installed = fs5.existsSync(path6.join(MODEL_DIR, name, "DONE"));
  if (!installed) {
    console.error(chalk.red(`Model ${name} not installed`));
    console.error(chalk.red(`Run "vosk install ${name}" to install it`));
    process.exit(1);
  }
  if (!fs5.existsSync(audio)) {
    console.error(chalk.red(`Audio file ${audio} not found`));
    process.exit(1);
  }
  if (opts.convert) {
    const spinner2 = opts.silent ? void 0 : ora2(`Converting ${audio} ...`).start();
    audio = convert(audio);
    spinner2 == null ? void 0 : spinner2.succeed(`Successfully converted ${audio}`);
  }
  const spinner = opts.silent ? void 0 : ora2(`Recognizing ${audio} ...`).start();
  const results = await recognize(path6.join(MODEL_DIR, name), audio, spinner);
  spinner == null ? void 0 : spinner.succeed(`Recognized ${audio}`);
  if (opts.text) {
    console.log(results.map((r) => r.sentence).join("\n"));
  } else {
    console.log(JSON.stringify(results, null, 2));
  }
});
program.command("microphone <model>").alias("mic").description("Recognize text from microphone").option("-o, --output <file>", "Save the transcription to a file").option("-f, --force", "Force overwrite the output file if it exists").option("-t, --time", "Print the time before each sentence in file").action(async (model, opts) => {
  const name = resolve_model(model);
  const installed = fs5.existsSync(path6.join(MODEL_DIR, name, "DONE"));
  if (!installed) {
    console.error(chalk.red(`Model ${name} not installed`));
    console.error(chalk.red(`Run "vosk install ${name}" to install it`));
    process.exit(1);
  }
  if (opts.output && !opts.force && fs5.existsSync(opts.output)) {
    console.error(chalk.red(`Output file ${opts.output} already exists`));
    console.error(chalk.red(`Use -f or --force to forcely overwrite it`));
    process.exit(1);
  }
  const start_t = Date.now();
  const mic2 = new Microphone(path6.join(MODEL_DIR, name));
  if (opts.output) {
    mic2.on("sentence", (sentence) => {
      const time = ((Date.now() - start_t) / 1e3).toFixed(1).padStart(6);
      const line = opts.time ? `[${time}] ${sentence}` : sentence;
      fs5.appendFileSync(opts.output, line + "\n");
    });
  }
  mic2.start();
  process.on("SIGINT", () => {
    mic2.stop();
  });
});
program.parse(process.argv);
